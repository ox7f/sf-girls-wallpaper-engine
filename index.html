<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Spine Animation for Wallpaper Engine</title>
    <style>
      body,
      html {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script src="pixi.min.js"></script>
    <script src="pixi-spine.min.js"></script>
    <script>
      const app = createPixiApp();

      let animation;
      let container;

      const backgroundPaths = [
        "assets/background/bg_home_rider_sky.png",
        "assets/background/bg_home_rider.png",
        "assets/background/bg_home_rider_smoke.png",
        "assets/background/bg_home_rider_light.png",
      ];

      const configuration = {
        agent: "Midori",
        lewdness: 1,
        allowClick: true,
        allowDrag: true,
        alpha: 1,
        angle: 0,
        scale: 0.5,
        offsetX: localStorage.getItem("offsetX"),
        offsetY: localStorage.getItem("offsetY"),
        timeScale: 1,
      };

      document.body.appendChild(app.view);
      loadBackground(app, backgroundPaths);

      window.wallpaperPropertyListener = {
        applyUserProperties: async function (properties) {
          if (properties.agent) {
            const { value } = properties.agent;
            configuration.agent = value;
            await loadAgent(app);
          }
          if (properties.lewdness) {
            const value = parseInt(properties.lewdness.value);
            configuration.lewdness = value;
            animation.state.setAnimation(0, `Idle ${value}`, true);
          }
          if (properties.allowclick) {
            configuration.allowClick = !!properties.allowclick.value;
          }
          if (properties.allowdrag) {
            configuration.allowDrag = !!properties.allowdrag.value;
          }
          if (properties.alpha) {
            const value = parseFloat(properties.alpha.value);
            configuration.alpha = value;
            container.alpha = value;
          }
          if (properties.angle) {
            const value = parseInt(properties.angle.value);
            configuration.angle = value;
            container.angle = value;
          }
          if (properties.scale) {
            const value = parseFloat(properties.scale.value);
            configuration.scale = value;
            container.scale.set(value);
          }
          if (properties.timescale) {
            const value = parseFloat(properties.timescale.value);
            configuration.timeScale = value;
            animation.state.timeScale = value;
          }
        },
      };

      function createPixiApp() {
        return new PIXI.Application({
          resizeTo: window,
          backgroundAlpha: 0,
          resolution: window.devicePixelRatio ?? 1,
          autoDensity: true,
        });
      }

      function createPixiContainer() {
        const pixiContainer = new PIXI.Container();
        pixiContainer.interactive = true;
        return pixiContainer;
      }

      async function loadAgent() {
        const { agent, lewdness, timeScale } = configuration;
        try {
          const { spineData } = await PIXI.Assets.load(
            `assets/${agent}_Spine_Skin1.json`
          );

          if (!spineData) throw new Error("Could not load SpineData");

          if (animation) {
            app.stage.removeChild(container);
            container.destroy();
          }

          animation = new PIXI.spine.Spine(spineData);
          animation.state.timeScale = timeScale;
          animation.state.setAnimation(0, `Idle ${lewdness}`, true);

          container = createPixiContainer();
          container.addChild(animation);
          app.stage.addChild(container);

          setupContainerStyle(container);
          setupClickEvents(container);
          setupDragEvents(container);
        } catch (error) {
          console.error("Could not load Asset:", error);
        }
      }

      async function loadBackground(app, backgroundPaths) {
        try {
          await PIXI.Assets.load(backgroundPaths);

          backgroundPaths.forEach((path) => {
            const texture = PIXI.Texture.from(path);
            const sprite = new PIXI.Sprite(texture);

            const resizeSprite = () => {
              sprite.anchor.set(0.5);
              sprite.position.set(
                Math.round(app.screen.width / 2),
                Math.round(app.screen.height / 2)
              );
              const scale = Math.max(
                app.screen.width / sprite.width,
                app.screen.height / sprite.height
              );
              sprite.scale.set(Math.ceil(scale * 100) / 100);
            };

            resizeSprite();
            app.stage.addChild(sprite);
          });
        } catch (error) {
          console.error("Could not load Assets", error);
        }
      }

      function setupContainerStyle(container) {
        const bounds = container.getLocalBounds();
        container.alpha = configuration.alpha;
        container.angle = configuration.angle;
        container.pivot.x = bounds.x + bounds.width / 2;
        container.pivot.y = bounds.y + bounds.height / 2;
        container.position.x = Number(configuration.offsetX);
        container.position.y = Number(configuration.offsetY);
        container.scale.set(configuration.scale);
      }

      function setupClickEvents(container) {
        container.on("pointerdown", () => {
          const { allowClick, lewdness } = configuration;
          if (!allowClick) return;
          animation.state.setAnimation(0, `Touch ${lewdness}`, false);
          animation.state.addAnimation(0, `Idle ${lewdness}`, true, 0);
        });
      }

      let dragTarget;
      let newX;
      let newY;

      function setupDragEvents(container) {
        container
          .on("pointerdown", onDragStart)
          .on("pointerup", onDragEnd)
          .on("pointerupoutside", onDragEnd)
          .on("pointermove", onDragMove);

        function onDragStart(event) {
          if (!configuration.allowDrag) return;
          dragTarget = container;
          const position = event.data.getLocalPosition(container);
          dragTarget.pivot.set(position.x, position.y);
          dragTarget.position.set(event.data.global.x, event.data.global.y);
        }

        function onDragMove(event) {
          if (dragTarget) {
            newX = event.data.global.x;
            newY = event.data.global.y;

            dragTarget.x = newX;
            dragTarget.y = newY;
          }
        }

        function onDragEnd() {
          dragTarget = null;
          localStorage.setItem("offsetX", newX);
          localStorage.setItem("offsetY", newY);
        }
      }
    </script>
  </body>
</html>
